## huffman0


#### コンパイル
```make```
#### 実行
```.bin/huffman <filename>```

課題1のファイルです。ハフマン符号化を実装しています。
filename のファイルを読み込み、そのテキストに対応するハフマン符号化を実装しています。
元々同梱されていた news.txt を実行するとテストができます。


## huffman1
データのハフマン符号化および復号を行うプログラムを作成しました。

#### コンパイル
```make```
#### 実行
```.bin/huffman <mode> <outputfile> <inputfile>```

次の2つの mode が存在します。
### mode = "cp_basic"

huffman0 で実装したハフマン符号による圧縮を用いて inputfile のデータを圧縮しています。圧縮ファイル形式は .huff です。 outputfile というファイルを出力します。

次のようなデータ形式で出力します。


次のようなデータ形式で出力します。
1. 最初の8バイトに、FD8A5902 FDB97531 を付加し、これをfilename 形式の識別子としています。
2. その次の1バイトには、符号の個数が4バイトで書かれています。最大128個です。
3. そして次に、符号のリストが並びます。各1バイトです。
4. その次には、再び FD8A5902 FDB97531 という識別子が入ります。
5. 次に、符号語の長さが並びます。各4バイトです。
6. 次に、符号語が並びます。各8バイト (long) です。 000101 なら、 後ろから順に解釈していきます。64 + 0 + 16 + 0 + 0 + 0 で 80 が格納されます。 64以上のサイズを持つ暗号には対応できませんが、そういう状況は起こりません。理由は、圧縮後のデータサイズの限界が1MBと決めてあるのでその範囲内では起こりようがないからです。
7. その次には、再び FD8A5902 FDB97531 という識別子が入ります。
8. この次の8バイトには、圧縮データのサイズが入ります。この時に、1MB以上のサイズの場合はエラーが出て終了します。
9. その次からは、圧縮後のデータが入ります。
10. このデータの後にまた FD8A5902 FDB97531 という識別子が入ります。

ファイルサイズは圧縮後が約3～4倍になりますが、テスト用の文章でも、画像でも完全に復元できます。


### mode = "ex_basic"

huffman0 で実装したハフマン符号による圧縮方式とみなし、データを展開します。
filename2 として出力します。

例えば、
```.bin/huffman cp_basic news.huff news.txt```
とすると、news.txt が変換された news.huff を作成することができます。
```.bin/huffman ex_basic news2.txt news.huff```
とすると復号します。

